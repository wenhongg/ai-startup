# Improvement Proposal

## Title: Implement Cycle Status & History Endpoints

## Description:

This pull request implements the cycle status and history endpoints as per the requirements. These endpoints provide real-time cycle status and historical cycle data to the user, improving transparency and enabling better monitoring and debugging of the self-improvement process.
Changes will be made to:
- Add a `/cycle/status` endpoint: This endpoint will return the current status of the running cycle ("idle", "running", "completed", "failed"), along with relevant details such as the current phase ("analyzing", "proposing", "implementing", "reviewing") and specific details for each phase. If a cycle has completed or failed, the endpoint will provide start/end times and a summary of changes or failure details.
- Add a `/cycle/history` endpoint: This endpoint will return a list of completed improvement cycles with a configurable limit (default 20), including the start and end times, status ("completed" or "failed"), and a short summary of the changes made.
- Refactor the `Observability` class: Implement methods to read cycle data back in a structured format (JSON).
- Error Handling: Implement basic error handling for any issues during parsing or file reads.
These changes are beneficial because they:
- Increase the transparency of the self-improvement process.
- Allow users (including the Founder AI) to monitor the progress and history of improvement cycles.
- Facilitate debugging and troubleshooting.
- Build trust in the system.
Potential impacts:
- Performance impact on the `/cycle/history` endpoint due to file reads, especially if the number of completed cycles and log file sizes are large. This is mitigated by a cycle limit.
- Possible errors during file parsing and data retrieval from log files, so the code handles those errors.
Testing will include:
- Unit tests for the new `Observability` methods to ensure correct data retrieval and parsing.
- Integration tests for the `/cycle/status` and `/cycle/history` endpoints, verifying that the correct data is returned in various scenarios (idle, running, completed, failed, with and without errors).
- Manual testing to verify the endpoints are working and display the information correctly, including testing failure cases.

## Files to Change:
- src/main.py
- src/observability.py
- tests/test_main.py
- tests/test_observability.py

## Original Proposal from Founder:
Okay, I'm ready to analyze the current state and propose improvements. Let's focus on improving the user experience related to monitoring and understanding the progress of the self-improvement cycles.

**1. Analysis of current state**

*   **Problem:** Currently, the system logs cycle data to individual files (as mentioned in the `src/observability.py` summary), and the `main.py` file has a simple API endpoint for triggering a cycle and a `root` endpoint that's a health check. There's no easy way for a user (or even the Founder AI) to:
    *   See the current status of a running cycle.
    *   View the history of completed cycles in a convenient format.
    *   Receive notifications about the progress or completion of cycles.
    *   Understand the detailed changes.
*   **Impact:** This lack of visibility limits the user's understanding of how the system is working, preventing them from:
    *   Trusting the system.
    *   Debugging issues.
    *   Evaluating the effectiveness of the changes.
    *   Providing feedback for better performance
*   **Specific Code Areas:**
    *   `src/observability.py`: Responsible for recording cycle data to files.
    *   `src/main.py`: Contains the FastAPI endpoint.
    *   `src/orchestrator.py`: Runs the improvement cycle.

**2. Proposed Improvement**

**Improvement: Enhance cycle monitoring and provide a basic API for status and history.**

*   **Actionable Steps:**
    1.  **Implement a Status Endpoint:**
        *   Modify `src/main.py` to add a new FastAPI endpoint (e.g., `/cycle/status`) that returns the current status of any running improvement cycle.
        *   The endpoint should query the `Observability` class (instantiated in `main.py` - or potentially in a global scope or container) to retrieve the current cycle data (e.g., analysis details, proposal, implementation plan, and changes).
        *   If no cycle is currently running, the endpoint returns a "idle" or "no cycle in progress" status.
    2.  **Implement a History Endpoint:**
        *   Modify `src/main.py` to add another new FastAPI endpoint (e.g., `/cycle/history`) that returns a list of completed improvement cycles, with a maximum number of cycles to limit responses to a reasonable size (e.g., 20, configurable).
        *   The endpoint needs to parse and combine the cycle data from the file storage (from `src/observability.py`) into a structured response (e.g., JSON). The endpoint can sort by cycle start time for chronological order, and limit to `cycle_limit` if it is a large number.
        *   The response for each cycle should include summary information (start/end times, status, basic description of changes made, and a link to view the details.
    3.  **Refactor `Observability`:**
        *   Add methods to read cycle data back in a structured format.
        *   Implement basic error handling for any issues during parsing or the file reads.
    4.  **Consider websockets (stretch goal):**
        *   To provide near real-time updates on the cycle status to the frontend, which allows for faster progress visibility.

*   **Developer AI Instructions:**
    ```
    You are a Developer AI.  Implement the following changes to enhance the user experience.

    1.  **Modify `src/main.py`:**
        *   Add a new FastAPI endpoint `/cycle/status` that returns a JSON response with the current status of the improvement cycle.  The response should include:
            *   `status`: (string, "idle", "running", "completed", or "failed")
            *   If `status` is "running":
                *   `phase`: (string, current phase - e.g., "analyzing", "proposing", "implementing", "reviewing")
                *   `details`: (object, specific details relevant to the current phase - example : Analysis description, Proposal description, and changes).
            *   If `status` is "completed" or "failed":
                *   `start_time`: (datetime, start time)
                *   `end_time`: (datetime, end time)
                *   `changes`: (list of strings, summary of changes or failure details).
        *   Add a new FastAPI endpoint `/cycle/history` that returns a JSON response with a list of completed improvement cycles.  Each cycle entry in the list should include:
            *   `start_time`: (datetime)
            *   `end_time`: (datetime)
            *   `status`: (string, "completed" or "failed")
            *   `summary`: (string, short description of changes, less than 200 characters)
        *   Use the `src.observability.Observability` class (instantiated in `main.py`) to get cycle status and history data.
        *   Handle errors gracefully and return appropriate HTTP status codes (e.g., 500 for internal server errors).
        *   Use the `src.config.settings` object (instantiated in `main.py`) to retrieve the `cycle_limit`.
    2.  **Modify `src/observability.py`:**
        *   Add methods to read the cycle data from the storage (files). Ensure to parse the files from the specific file names (as configured in the deployment file, for instance,  `/opt/ai-startup/logs/cycles/` ) from the start time.
        *   Refactor the code to handle exceptions gracefully and provide helpful error messages.
    3.  **Ensure code is well-documented and follows existing coding style.**
    ```

**3. Priority Level (2)**

*   **Justification:** This is a relatively high priority because it significantly improves the user's ability to monitor and understand the system's behavior, builds trust, and enables easier debugging. Implementation should be relatively easy.

**4. Success Criteria**

*   The `/cycle/status` endpoint returns the correct status (idle, running, completed, failed) with relevant details based on the current state of the cycle.
*   The `/cycle/history` endpoint returns a list of completed cycles with a reasonable limit of recent cycles, including a summary of the changes.
*   The endpoints function correctly with no errors.
*   The code is well-documented and adheres to existing code style.
*   The system runs successfully.
*   The founder is able to monitor the cycles.

**5. Potential Risks**

*   **Increased Complexity:** Adding endpoints and data retrieval could introduce some complexity to the code, but with proper design and refactoring, this risk can be minimized.
*   **Performance Issues:** Reading cycle data from files repeatedly could become a performance bottleneck if the file size of logs increases. The implementation should consider the performance impact on high-volume systems.
*   **Incomplete or Incorrect Data:** Potential for errors during log file parsing and reading can lead to incorrect or incomplete status and history information, so the implementation must handle these gracefully and correctly.

